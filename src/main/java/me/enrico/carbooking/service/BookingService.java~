package me.enrico.carbooking.service;

import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import me.enrico.carbooking.model.Booking;
import me.enrico.carbooking.model.Car;
import me.enrico.carbooking.model.User; // Aggiungi import
import me.enrico.carbooking.repositories.BookingRepository;
import me.enrico.carbooking.request.CarBookingRequest;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional; // Assicurati che sia importato
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.ZoneId; // Assicurati che sia importato
import java.time.ZonedDateTime;
import java.util.List;
import java.time.temporal.ChronoUnit; // Aggiungi import

@Service
@RequiredArgsConstructor
public class BookingService {

    private final BookingRepository bookingRepository;
    // private final CarRepository carRepository; // Non sembra essere usato qui direttamente
    private static final ZoneId ROME_ZONE = ZoneId.of("Europe/Rome");

    @Transactional
    public String createBooking(Car car, CarBookingRequest request, User currentUser) { // Aggiunto User currentUser
        validateBookingRequest(request);
        checkForOverlappingBookings(car.getId(), request);

        Booking booking = new Booking();
        booking.setCar(car);
        booking.setUser(currentUser); // Imposta l'utente corrente
        booking.setBookedAt(LocalDateTime.now(ROME_ZONE));
        booking.setStartDateTime(request.getStartDateTime());
        booking.setEndDateTime(request.getEndDateTime());
        booking.setDuration(calculateDuration(request));
        booking.setReason(request.getReason());
        booking.setActive(true);

        bookingRepository.save(booking);

        // Aggiorna il messaggio per includere il nome dell'utente se disponibile
        String userName = (currentUser != null && currentUser.getFirstName() != null) ? currentUser.getFirstName() : currentUser.getUsername();
        return String.format("%s, hai prenotato con successo l'auto %s!", userName, car.getName());
    }

    private void validateBookingRequest(CarBookingRequest request) {
        if (request.getStartDateTime() == null || request.getEndDateTime() == null) {
            throw new IllegalArgumentException("Le date di inizio e fine prenotazione sono obbligatorie.");
        }
        if (request.getStartDateTime().isBefore(LocalDateTime.now(ROME_ZONE).minusMinutes(5))) { // Tolleranza di 5 minuti per richieste immediate
            throw new IllegalArgumentException("La data di inizio non può essere nel passato.");
        }
        if (request.getEndDateTime().isBefore(request.getStartDateTime()) || request.getEndDateTime().isEqual(request.getStartDateTime())) {
            throw new IllegalArgumentException("La data di fine deve essere successiva alla data di inizio.");
        }
    }

    private void checkForOverlappingBookings(Long carId, CarBookingRequest request) {
        List<Booking> existingBookings = bookingRepository.findByCarIdAndActiveTrue(carId);
        for (Booking existingBooking : existingBookings) {
            if (existingBooking.overlaps(request.getStartDateTime(), request.getEndDateTime())) {
                throw new IllegalStateException("L'auto è già prenotata per il periodo selezionato.");
            }
        }
    }

    private int calculateDuration(CarBookingRequest request) {
        if (request.getStartDateTime() == null || request.getEndDateTime() == null) {
            return 0;
        }
        // Calcola la durata in ore, arrotondando per eccesso
        long minutes = ChronoUnit.MINUTES.between(request.getStartDateTime(), request.getEndDateTime());
        return (int) Math.ceil((double) minutes / 60.0);
    }
}